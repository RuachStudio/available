generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")  // pooled (6543) for Prisma Client/runtime
  directUrl = env("DIRECT_URL")    // direct (5432) for Prisma migrate/Studio
}

// --- Enums ---
// Use an enum for shirt sizes; map 2XL/3XL to valid identifiers
enum ShirtSize {
  XS
  S
  M
  L
  XL
  E2XL @map("2XL")
  E3XL @map("3XL")
}

// --- Models ---
model Registration {
  id               String     @id @default(uuid())
  contactName      String
  contactPhone     String?    @unique
  contactEmail     String?    @unique
  contactAddress   String?
  prayerRequest    String?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Primary contact optional shirt
  primaryWantsShirt Boolean    @default(false)
  primaryShirtSize   ShirtSize?

  attendees        Attendee[]

  @@index([createdAt])
  @@index([contactEmail])
  @@index([contactPhone])
}

model Attendee {
  id             String       @id @default(uuid())
  name           String
  phone          String?
  email          String?
  address        String?

  // Optional shirt per attendee
  wantsShirt     Boolean      @default(false)
  shirtSize      ShirtSize?

  notes          String?
  registrationId String
  registration   Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  @@index([registrationId])
  @@index([wantsShirt, shirtSize])
}

model SpeakerPoll {
  id        Int      @id @default(autoincrement())
  speaker   String   @unique
  votes     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Payment {
  id           String   @id @default(cuid())
  stripeId     String   @unique
  amountCents  Int
  currency     String
  email        String?
  name         String?
  type         String   // "donation" | "shirt"
  shirtSize    String?
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([type])
}
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { prisma } from "@/lib/prisma";

export const runtime = "nodejs";
export const dynamic = "force-dynamic"; // ensure this always runs on the server

function getStripe(): Stripe {
  const key = process.env.STRIPE_SECRET_KEY;
  if (!key) throw new Error("STRIPE_SECRET_KEY not set");
  return new Stripe(key);
}

function getWebhookSecret(): string {
  const secret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!secret) throw new Error("STRIPE_WEBHOOK_SECRET not set");
  return secret;
}

export async function POST(req: NextRequest) {
  const stripe = getStripe();
  const sig = req.headers.get("stripe-signature");
  if (!sig) {
    return NextResponse.json({ error: "Missing Stripe signature" }, { status: 400 });
  }

  let event: Stripe.Event;

  try {
    const rawBody = await req.text(); // IMPORTANT: use raw body for signature verification
    event = stripe.webhooks.constructEvent(rawBody, sig, getWebhookSecret());
  } catch (err) {
    console.error("❌ Webhook signature verification failed:", err);
    return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
  }

  try {
    if (event.type === "checkout.session.completed") {
      const session = event.data.object as Stripe.Checkout.Session;

      // Expand useful fields
      const full = await stripe.checkout.sessions.retrieve(session.id, {
        expand: ["payment_intent", "customer", "custom_fields"],
      });

      const amountTotal = full.amount_total ?? 0; // cents
      const currency = (full.currency || "usd").toLowerCase();
      const customerEmail = full.customer_details?.email || full.customer_email || null;
      const customerName = full.customer_details?.name || null;
      const paymentStatus = full.payment_status; // expected 'paid'

      // Extract optional shirt size from checkout custom fields
      let shirtSize: string | null = null;
      if (Array.isArray(full.custom_fields)) {
        const field = full.custom_fields.find((f) => f.key === "shirt_size");
        if (field) {
          if (field.type === "dropdown") shirtSize = field.dropdown?.value || null;
          if (field.type === "text") shirtSize = field.text?.value || null;
        }
      }

      const kind = full.submit_type === "donate" || (full.metadata?.source ?? "").includes("donation")
        ? "donation"
        : "shirt";

      // Persist a simple payment record (idempotent by stripeId)
      await prisma.payment.upsert({
        where: { stripeId: full.id },
        update: {},
        create: {
          stripeId: full.id,
          amountCents: amountTotal,
          currency,
          email: customerEmail,
          name: customerName,
          type: kind,
          shirtSize: kind === "shirt" ? shirtSize : null,
        },
      });

      console.log("✅ checkout.session.completed", {
        id: full.id,
        paymentStatus,
        amountTotal,
        currency,
        customerEmail,
        customerName,
        shirtSize,
        kind,
      });
    }

    return NextResponse.json({ received: true });
  } catch (err) {
    console.error("❌ Webhook handler error:", err);
    // Return 200 to avoid repeated retries if it's our own internal failure we already logged
    return NextResponse.json({ received: true, note: "handler error" });
  }
}
